# -*- coding: utf-8 -*-
"""g_optimization.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ebH4_Hj2KYF5luWVoAeeWrA0N6QCFBj9
"""

import math
import numpy

class Robot:
  r_flywheel = 1
  r_wheel = 1
  L_robot = 1
  w = 1
  valid_configuration=False
  
  N = 2
  m_battery = .150#.15
  m_motor = .175
  m_wheel = .15
  m_rest = 4 * m_battery + 3 * m_motor + 2 * m_wheel +.25

  L_rest = 0.4
  r_external=0.5/2.0
  g = 9.81
  rho_flywheel=7850
  h=.01
  b=.005

  A_drag = .01
  rho = 1.2
  C_D = 1

  
  motor_max_speed = 176*2*math.pi/60.0
  motor_max_torque = 5 * 9.8 / 100.0
  
  def __init__(self):
    pass
    
  def r_cylinder(self):
    return 0.28 * self.r_flywheel

  def r_max(self):
    return self.r_flywheel - self.r_cylinder()

  def r_min(self):
    return 0.28 * self.r_flywheel + 0.015
  

  def m_cylinder(self):
    return  self.w * (self.r_cylinder())**2 * self.rho_flywheel * math.pi
  
  def m_flywheel(self):
    return self.N * self.m_cylinder()
  
  def I_flywheel(self, radius=0):
    if radius == 0:
      return self.N * self.m_cylinder() * (self.r_max())**2
    else:
      return (self.N-1) * self.m_cylinder() * (self.r_max())**2 + self.m_cylinder() * (radius)**2
    
  def I_wheel(self):
      return self.m_wheel * (self.r_wheel)**2

  def I_platform(self):
      return self.m_total() * 0.5 * (self.r_wheel)**2

  def m_total(self):
    return self.m_rest + self.m_flywheel() 
  
  def get_R(self):
    return self.I_flywheel()/(self.m_total()*self.r_wheel**2+2*self.I_wheel())

  def get_L(self):
    return self.L_rest + self.w
  
  def set_r_flywheel_r_wheel_w(self,r_flywheel,r_wheel,w):
    self.r_flywheel = r_flywheel
    self.r_wheel = r_wheel
    self.w = w
    if(self.r_wheel < math.sqrt((r_flywheel+self.b)**2+(self.h/2)**2)):
      self.valid_configuration = False
    elif(self.r_external < math.sqrt(self.r_wheel**2+(self.get_L()/2)**2)):
      self.valid_configuration = False
    elif(self.m_total()>7):
      self.valid_configuration = False
    elif(self.r_max()<self.r_min()):
      self.valid_configuration = False
    else:
      self.valid_configuration = True

  def set_r_flywheel_r_wheel_w_N(self,r_flywheel,r_wheel,w,N):
    self.N = N
    self.set_r_flywheel_r_wheel_w(r_flywheel,r_wheel,w)

  def get_values(self):
    return {}
    
  def max_speed_horizontal_flywheel(self):
    if(not self.valid_configuration):
      return 0
    return self.motor_max_speed * self.get_R() * self.r_wheel

  def max_speed_horizontal_pendulum(self):
    if(not self.valid_configuration):
      return 0
    return min(math.sqrt((2*self.m_cylinder() * self.g *(self.r_max()-self.r_min()) )/(self.rho * self.C_D * self.A_drag* self.r_wheel)),self.motor_max_speed*self.r_wheel)

  def max_height_flywheel(self):
    if(not self.valid_configuration):
      return 0
    return self.motor_max_speed * self.max_speed_horizontal_flywheel() * self.I_flywheel() / (self.m_total() * self.g * self.r_flywheel)
  
  def max_acceleration_horizontal_flywheel(self):
    if(not self.valid_configuration):
      return 0
    return self.get_R() * self.r_wheel * self.motor_max_torque/(self.I_flywheel())
  
  def max_acceleration_horizontal_pendulum(self):
    if(not self.valid_configuration):
      return 0
    return self.m_cylinder() * self.g * (self.r_max()-self.r_min())/(self.r_wheel *self.m_total()+ 2* self.I_wheel()/self.r_wheel)

  def max_sin_pendulum(self):
    if(not self.valid_configuration):
      return 0
    return min(1,min(self.m_cylinder() * self.g * (self.r_max()-self.r_min()) ,self.motor_max_torque)/(self.r_wheel *  self.m_total()*self.g))

  def max_sin_flywheel(self):
    if(not self.valid_configuration):
      return 0
    return min(1,self.motor_max_torque /(self.r_wheel *self.m_total()* self.g))

  ##height flywheel computations
  def omega(self,t):
    return self.motor_max_speed * t + (self.motor_max_speed**2 * self.I_flywheel()/self.motor_max_torque)*((math.e**(-t*self.motor_max_torque/(self.I_flywheel()*self.motor_max_speed)))-1)

  def dot_omega(self,t):
    return self.motor_max_speed - self.motor_max_speed * math.e**(-t*self.motor_max_torque/(self.I_flywheel()*self.motor_max_speed))

  def A_height(self):
    return (self.r_wheel/(2*self.I_flywheel()+self.m_total()*self.r_wheel**2))

  def B_height(self, alpha):
    return -(self.m_total()*self.g*math.sin(alpha)*self.r_wheel**2/(2*self.I_wheel()+self.m_total()*self.r_wheel**2))
  
  def dot_y(self,t,alpha):
    return self.A_height()*self.I_flywheel()*self.dot_omega(t)+self.B_height(alpha)*t

  def height(self,t,alpha):
    return math.sin(alpha)*(self.A_height()*self.I_flywheel()*self.omega(t)+t**2 * self.B_height(alpha)/2)

  def max_h(self,alpha):    
    return 1

  def max_torque(self,dot_omega):
    return self.motor_max_torque - (dot_omega/self.motor_max_speed)*self.motor_max_torque
